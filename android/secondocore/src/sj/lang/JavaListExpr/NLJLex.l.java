/*
----
This file is part of SECONDO.
Copyright (C) 2004, University in Hagen, Department of Computer Science,
Database Systems for New Applications.
SECONDO is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
SECONDO is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with SECONDO; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
----
Scanner for the ListExpr class.
March, 1999. Jose Antonio Cotelo Lema.
June 1999: added to the package sj.lang.JavaListExpr
August 1999: changed the grammar for <symbolAthom>. Now either starts with a letter, followed only by letters, digits or underline characters, or contains only other characters (e.g. mathematic characters, dots, colons, etc..).
This file is an input file for the Java Lexical Analizer Generator JLEX.
The output file generated by JLEX will be a .java file defining a class NLTokenizer that will be an scaner for nested lists.
The initial state is YYINITIAL.
The lexical rules are in the form [<state>] <expression> {<action>}, where
the <state> is optional (in this case this rule is valid in any states),
<expression> is a lexical rule with almost the same syntaxis than is used
in Lex, and <action> is a block of Java code.
The tokens accepted by this scanner follow the following rules:
        <boolAtom> =        { 'TRUE' | 'FALSE' }
        <intAtom> =        <sign> <number>
        <sign> =        ['-']  // This includes the option of having no sign.
        <realAtom> =        <sign> <number> '.' <number>
                |        <sign> <number> '.' <number> <exponent>
                |        <sign> <number> <exponent>
        <stringAtom> =        '"' <characterSeq> '"'
        <symbolAtom> =        <letter> {<letter> | <digit> | <underline>}*
                |        <otherChar> {<otherChar>}*
        <textAtom> =        '<' text '>' {<anyChar>}* '<' '\' text '-' '-' '-' '>'
Where:
        <number> =        <digit> {<digit>}*
        <exponent> =        'E' <sign> <number>
        <characterSeq> =        <stringCharacter> <characterSeq>
                |
        <anyChar> =        <any possible character>
        <letter> =        'A'-'Z'
                |        'a'-'z'
        <digit> =        '0'-'9'
        <stringCharacter> =        <any character except the doble quote
                                 character>
        <underline> =        <The underline character '_'>
        <otherChar> =        <any character which is neither a <letter> nor a
                         <digit> nor a '"', '(' or ')'>
*/
package sj.lang.JavaListExpr;
import lib.java_cup10.runtime.*;
import sj.lang.ListExpr;
import java.io.*;
import tools.Base64Encoder;
import tools.Reporter;
class NLToken extends Symbol implements NLSymbol{
  // It extends the Symbol class to allow return the line and character where
  // the scanner is reading.
  /* Variables. */
  // This variable returns the number of character of the first character on
  // this token. It considers the first character as character 1.
  public int charPos;
  // This variable returns the number of line of the first character on
  // this token. It considers the first line as line 1.
  public int linePos;
  /* Class Constructor */
  public NLToken(int type, Object value,int charPos, int linePos){
    super(type);
    this.value = value;
    this.charPos = charPos;
    this.linePos = linePos;
  }
}


class NLTokenizer {
	private final int YY_BUFFER_SIZE = 512;
	private final int YY_F = -1;
	private final int YY_NO_STATE = -1;
	private final int YY_NOT_ACCEPT = 0;
	private final int YY_START = 1;
	private final int YY_END = 2;
	private final int YY_NO_ANCHOR = 4;
	private final int YY_BOL = 65536;
	private final int YY_EOF = 65537;

  // Code for the NLTokenizer class, defining internal variables.
  // The textContent variable stores the part of the textAtom that has been
  // read. It is used only when a textAtom is being parsed.
  private StringBuffer textContent = new StringBuffer();
  // Defines if the class must show extra information when errors are detected.
  private static final boolean DEBUG_MODE = true;
	private java.io.BufferedReader yy_reader;
	private int yy_buffer_index;
	private int yy_buffer_read;
	private int yy_buffer_start;
	private int yy_buffer_end;
	private char yy_buffer[];
	private int yychar;
	private int yyline;
	private boolean yy_at_bol;
	private int yy_lexical_state;

	NLTokenizer (java.io.Reader reader) {
		this ();
		if (null == reader) {
			throw (new Error("Error: Bad input stream initializer."));
		}
		yy_reader = new java.io.BufferedReader(reader);
	}

	NLTokenizer (java.io.InputStream instream) {
		this ();
		if (null == instream) {
			throw (new Error("Error: Bad input stream initializer."));
		}
		yy_reader = new java.io.BufferedReader(new java.io.InputStreamReader(instream));
	}

	private NLTokenizer () {
		yy_buffer = new char[YY_BUFFER_SIZE];
		yy_buffer_read = 0;
		yy_buffer_index = 0;
		yy_buffer_start = 0;
		yy_buffer_end = 0;
		yychar = 0;
		yyline = 0;
		yy_at_bol = true;
		yy_lexical_state = YYINITIAL;
	}

	private boolean yy_eof_done = false;
	private final int COMMENT_STATE = 3;
	private final int YYINITIAL = 0;
	private final int TEXTATOM_SIMPLE = 2;
	private final int TEXTATOM_STATE = 1;
	private final int yy_state_dtrans[] = {
		0,
		55,
		68,
		69
	};
	private void yybegin (int state) {
		yy_lexical_state = state;
	}
	private int yy_advance ()
		throws java.io.IOException {
		int next_read;
		int i;
		int j;

		if (yy_buffer_index < yy_buffer_read) {
			return yy_buffer[yy_buffer_index++];
		}

		if (0 != yy_buffer_start) {
			i = yy_buffer_start;
			j = 0;
			while (i < yy_buffer_read) {
				yy_buffer[j] = yy_buffer[i];
				++i;
				++j;
			}
			yy_buffer_end = yy_buffer_end - yy_buffer_start;
			yy_buffer_start = 0;
			yy_buffer_read = j;
			yy_buffer_index = j;
			next_read = yy_reader.read(yy_buffer,
					yy_buffer_read,
					yy_buffer.length - yy_buffer_read);
			if (-1 == next_read) {
				return YY_EOF;
			}
			yy_buffer_read = yy_buffer_read + next_read;
		}

		while (yy_buffer_index >= yy_buffer_read) {
			if (yy_buffer_index >= yy_buffer.length) {
				yy_buffer = yy_double(yy_buffer);
			}
			next_read = yy_reader.read(yy_buffer,
					yy_buffer_read,
					yy_buffer.length - yy_buffer_read);
			if (-1 == next_read) {
				return YY_EOF;
			}
			yy_buffer_read = yy_buffer_read + next_read;
		}
		return yy_buffer[yy_buffer_index++];
	}
	private void yy_move_end () {
		if (yy_buffer_end > yy_buffer_start &&
		    '\n' == yy_buffer[yy_buffer_end-1])
			yy_buffer_end--;
		if (yy_buffer_end > yy_buffer_start &&
		    '\r' == yy_buffer[yy_buffer_end-1])
			yy_buffer_end--;
	}
	private boolean yy_last_was_cr=false;
	private void yy_mark_start () {
		int i;
		for (i = yy_buffer_start; i < yy_buffer_index; ++i) {
			if ('\n' == yy_buffer[i] && !yy_last_was_cr) {
				++yyline;
			}
			if ('\r' == yy_buffer[i]) {
				++yyline;
				yy_last_was_cr=true;
			} else yy_last_was_cr=false;
		}
		yychar = yychar
			+ yy_buffer_index - yy_buffer_start;
		yy_buffer_start = yy_buffer_index;
	}
	private void yy_mark_end () {
		yy_buffer_end = yy_buffer_index;
	}
	private void yy_to_mark () {
		yy_buffer_index = yy_buffer_end;
		yy_at_bol = (yy_buffer_end > yy_buffer_start) &&
		            ('\r' == yy_buffer[yy_buffer_end-1] ||
		             '\n' == yy_buffer[yy_buffer_end-1] ||
		             2028/*LS*/ == yy_buffer[yy_buffer_end-1] ||
		             2029/*PS*/ == yy_buffer[yy_buffer_end-1]);
	}
	private java.lang.String yytext () {
		return (new java.lang.String(yy_buffer,
			yy_buffer_start,
			yy_buffer_end - yy_buffer_start));
	}
	private int yylength () {
		return yy_buffer_end - yy_buffer_start;
	}
	private char[] yy_double (char buf[]) {
		int i;
		char newbuf[];
		newbuf = new char[2*buf.length];
		for (i = 0; i < buf.length; ++i) {
			newbuf[i] = buf[i];
		}
		return newbuf;
	}
	private final int YY_E_INTERNAL = 0;
	private final int YY_E_MATCH = 1;
	private java.lang.String yy_error_string[] = {
		"Error: Internal error.\n",
		"Error: Unmatched input.\n"
	};
	private void yy_error (int code,boolean fatal) {
		java.lang.System.out.print(yy_error_string[code]);
		java.lang.System.out.flush();
		if (fatal) {
			throw new Error("Fatal Error.\n");
		}
	}
	private int[][] unpackFromString(int size1, int size2, String st) {
		int colonIndex = -1;
		String lengthString;
		int sequenceLength = 0;
		int sequenceInteger = 0;

		int commaIndex;
		String workString;

		int res[][] = new int[size1][size2];
		for (int i= 0; i < size1; i++) {
			for (int j= 0; j < size2; j++) {
				if (sequenceLength != 0) {
					res[i][j] = sequenceInteger;
					sequenceLength--;
					continue;
				}
				commaIndex = st.indexOf(',');
				workString = (commaIndex==-1) ? st :
					st.substring(0, commaIndex);
				st = st.substring(commaIndex+1);
				colonIndex = workString.indexOf(':');
				if (colonIndex == -1) {
					res[i][j]=Integer.parseInt(workString);
					continue;
				}
				lengthString =
					workString.substring(colonIndex+1);
				sequenceLength=Integer.parseInt(lengthString);
				workString=workString.substring(0,colonIndex);
				sequenceInteger=Integer.parseInt(workString);
				res[i][j] = sequenceInteger;
				sequenceLength--;
			}
		}
		return res;
	}
	private int yy_acpt[] = {
		/* 0 */ YY_NO_ANCHOR,
		/* 1 */ YY_NO_ANCHOR,
		/* 2 */ YY_NO_ANCHOR,
		/* 3 */ YY_NO_ANCHOR,
		/* 4 */ YY_NO_ANCHOR,
		/* 5 */ YY_NO_ANCHOR,
		/* 6 */ YY_NO_ANCHOR,
		/* 7 */ YY_NO_ANCHOR,
		/* 8 */ YY_NO_ANCHOR,
		/* 9 */ YY_NOT_ACCEPT,
		/* 10 */ YY_NO_ANCHOR,
		/* 11 */ YY_NO_ANCHOR,
		/* 12 */ YY_NO_ANCHOR,
		/* 13 */ YY_NO_ANCHOR,
		/* 14 */ YY_NO_ANCHOR,
		/* 15 */ YY_NO_ANCHOR,
		/* 16 */ YY_NO_ANCHOR,
		/* 17 */ YY_NO_ANCHOR,
		/* 18 */ YY_NO_ANCHOR,
		/* 19 */ YY_NO_ANCHOR,
		/* 20 */ YY_NO_ANCHOR,
		/* 21 */ YY_NO_ANCHOR,
		/* 22 */ YY_NO_ANCHOR,
		/* 23 */ YY_NO_ANCHOR,
		/* 24 */ YY_NO_ANCHOR,
		/* 25 */ YY_NO_ANCHOR,
		/* 26 */ YY_NO_ANCHOR,
		/* 27 */ YY_NO_ANCHOR,
		/* 28 */ YY_NO_ANCHOR,
		/* 29 */ YY_NOT_ACCEPT,
		/* 30 */ YY_NO_ANCHOR,
		/* 31 */ YY_NO_ANCHOR,
		/* 32 */ YY_NO_ANCHOR,
		/* 33 */ YY_NO_ANCHOR,
		/* 34 */ YY_NO_ANCHOR,
		/* 35 */ YY_NO_ANCHOR,
		/* 36 */ YY_NOT_ACCEPT,
		/* 37 */ YY_NO_ANCHOR,
		/* 38 */ YY_NO_ANCHOR,
		/* 39 */ YY_NO_ANCHOR,
		/* 40 */ YY_NOT_ACCEPT,
		/* 41 */ YY_NO_ANCHOR,
		/* 42 */ YY_NO_ANCHOR,
		/* 43 */ YY_NOT_ACCEPT,
		/* 44 */ YY_NO_ANCHOR,
		/* 45 */ YY_NO_ANCHOR,
		/* 46 */ YY_NOT_ACCEPT,
		/* 47 */ YY_NOT_ACCEPT,
		/* 48 */ YY_NOT_ACCEPT,
		/* 49 */ YY_NOT_ACCEPT,
		/* 50 */ YY_NOT_ACCEPT,
		/* 51 */ YY_NOT_ACCEPT,
		/* 52 */ YY_NOT_ACCEPT,
		/* 53 */ YY_NOT_ACCEPT,
		/* 54 */ YY_NOT_ACCEPT,
		/* 55 */ YY_NOT_ACCEPT,
		/* 56 */ YY_NOT_ACCEPT,
		/* 57 */ YY_NOT_ACCEPT,
		/* 58 */ YY_NOT_ACCEPT,
		/* 59 */ YY_NOT_ACCEPT,
		/* 60 */ YY_NOT_ACCEPT,
		/* 61 */ YY_NOT_ACCEPT,
		/* 62 */ YY_NOT_ACCEPT,
		/* 63 */ YY_NOT_ACCEPT,
		/* 64 */ YY_NOT_ACCEPT,
		/* 65 */ YY_NOT_ACCEPT,
		/* 66 */ YY_NOT_ACCEPT,
		/* 67 */ YY_NOT_ACCEPT,
		/* 68 */ YY_NOT_ACCEPT,
		/* 69 */ YY_NOT_ACCEPT,
		/* 70 */ YY_NO_ANCHOR,
		/* 71 */ YY_NOT_ACCEPT,
		/* 72 */ YY_NOT_ACCEPT,
		/* 73 */ YY_NO_ANCHOR,
		/* 74 */ YY_NOT_ACCEPT,
		/* 75 */ YY_NO_ANCHOR,
		/* 76 */ YY_NO_ANCHOR,
		/* 77 */ YY_NOT_ACCEPT,
		/* 78 */ YY_NOT_ACCEPT,
		/* 79 */ YY_NO_ANCHOR,
		/* 80 */ YY_NOT_ACCEPT,
		/* 81 */ YY_NOT_ACCEPT,
		/* 82 */ YY_NOT_ACCEPT,
		/* 83 */ YY_NOT_ACCEPT,
		/* 84 */ YY_NOT_ACCEPT,
		/* 85 */ YY_NOT_ACCEPT,
		/* 86 */ YY_NOT_ACCEPT,
		/* 87 */ YY_NOT_ACCEPT
	};
	private int yy_cmap[] = unpackFromString(1,65538,
"25:8,23:2,29,25,23,1,25:18,23,28,15,25:4,32,33,16,25,7,25,2,4,24,3:10,25:2," +
"18,25,22,25:2,12,26:3,5,11,26:5,13,26:5,9,14,8,10,26:5,25,17,25:2,27,25,26:" +
"4,6,19,26:2,20,26:2,21,26:7,30,26:3,31,26:2,25:65413,0:2")[0];

	private int yy_rmap[] = unpackFromString(1,88,
"0,1,2,3,4,5,1:3,6,1:2,7:2,1,8,1,9,1:8,10,11,12,13,5,14,15,16,17,18,5,19,20," +
"21,22,23,24,25,13,26,27,28,29,30,31,32,33,8,34,35,36,37,38,39,40,41,42,43,4" +
"4,45,46,47,48,49,50,51,52,53,54,55,7,56,57,58,59,60,61,62,63,64,65,66")[0];

	private int yy_nxt[][] = unpackFromString(67,34,
"1,2,26,3,34,4:2,27,35,76:2,79,76:3,5,6,27,39,76:3,27,2,27:2,76,28,27,2,76:2" +
",7,8,-1:35,2,-1:21,2,-1:5,2,-1:7,3,38,9:2,-1:29,29,41,-1,76:2,29,76:7,-1:4," +
"76:3,-1:4,76:2,-1:2,76:2,-1:3,36:14,10,36,40,36:16,-1:2,29,44,-1:3,29,-1:29" +
",76,-1,76:2,-1,76:7,-1:4,76:3,-1:4,76:2,-1:2,76:2,-1:4,53:16,87,53:10,-1,53" +
":4,-1:18,57,-1:17,27,3,34,9:2,27,-1:9,27:2,-1:3,27,-1,27:2,-1:2,27,-1:7,27," +
"-1,27,-1:2,27,-1:9,27:2,-1:3,27,-1,27:2,-1:2,27,-1:33,11,-1:8,44,-1:47,17,-" +
"1:33,22,-1:14,23,-1:28,25,-1:8,27,38,27,9:2,27,-1:9,27:2,-1:3,27,-1,27:2,-1" +
":2,27,-1:8,76,-1,76:2,-1,76,70,76:5,-1:4,76:3,-1:4,76:2,-1:2,76:2,-1:26,56," +
"-1:12,38,-1,9:2,-1:29,27,-1,27,-1:2,27,-1:9,27:2,43,-1:2,27,-1,27:2,-1:2,27" +
",-1,46,-1:4,36:14,30,36,40,36:16,-1:3,41,-1,76:2,-1,76:7,-1:4,76:3,-1:4,76:" +
"2,-1:2,76:2,-1:5,76,-1,12,76,-1,76:7,-1:4,76:3,-1:4,76:2,-1:2,76:2,-1:22,47" +
",-1:16,76,-1,13,76,-1,76:7,-1:4,76:3,-1:4,76:2,-1:2,76:2,-1:8,48,-1:48,49,-" +
"1:43,50,-1:8,51,-1:57,52,-1:25,53,-1:33,14,-1:13,53:16,87,53:3,15,53:6,-1,5" +
"3:4,1,16:16,31,37,16:15,-1:30,58,-1:27,59,-1:15,60,-1:57,61,-1:34,62,-1:8,6" +
"3,-1:57,64,-1:34,65,-1:4,78,-1:61,80,-1:25,18,-1:33,19,-1:11,1,20:16,32,20:" +
"14,21,20,1,-1,24:26,33,24:5,-1:3,76,-1,76:2,-1,76:2,42,76:4,-1:4,76:3,-1:4," +
"76:2,-1:2,76:2,-1:4,54,53:15,87,53:10,-1,53:4,-1:2,66,-1:34,76,-1,76:2,-1,7" +
"6:5,75,76,-1:4,76:3,-1:4,76:2,-1:2,76:2,-1:4,67,-1:34,76,-1,76:2,-1,76:6,45" +
",-1:4,76:3,-1:4,76:2,-1:2,76:2,-1:4,71,53:15,87,53:10,-1,53:4,-1:2,72,-1:34" +
",76,-1,76:2,-1,76:4,73,76:2,-1:4,76:3,-1:4,76:2,-1:2,76:2,-1:4,81,-1:33,74," +
"-1:33,77,53:15,87,53:10,-1,53:4,-1:2,53:4,82,53:11,87,53:10,-1,53:4,-1:2,53" +
":16,87,53:2,83,53:7,-1,53:4,-1:2,53:16,87,53,84,53:8,-1,53:4,-1:2,53:16,87," +
"85,53:9,-1,53:4,-1:2,53:16,87,53:5,86,53:4,-1,53:4");

	public NLToken nextToken ()
		throws java.io.IOException {
		int yy_lookahead;
		int yy_anchor = YY_NO_ANCHOR;
		int yy_state = yy_state_dtrans[yy_lexical_state];
		int yy_next_state = YY_NO_STATE;
		int yy_last_accept_state = YY_NO_STATE;
		boolean yy_initial = true;
		int yy_this_accept;

		yy_mark_start();
		yy_this_accept = yy_acpt[yy_state];
		if (YY_NOT_ACCEPT != yy_this_accept) {
			yy_last_accept_state = yy_state;
			yy_mark_end();
		}
		while (true) {
			if (yy_initial && yy_at_bol) yy_lookahead = YY_BOL;
			else yy_lookahead = yy_advance();
			yy_next_state = YY_F;
			yy_next_state = yy_nxt[yy_rmap[yy_state]][yy_cmap[yy_lookahead]];
			if (YY_EOF == yy_lookahead && true == yy_initial) {

  // If it detects the end of file (EOF) returns the EOF token.
  return(new NLToken(NLToken.EOF, null, yychar+1, yyline+1));
			}
			if (YY_F != yy_next_state) {
				yy_state = yy_next_state;
				yy_initial = false;
				yy_this_accept = yy_acpt[yy_state];
				if (YY_NOT_ACCEPT != yy_this_accept) {
					yy_last_accept_state = yy_state;
					yy_mark_end();
				}
			}
			else {
				if (YY_NO_STATE == yy_last_accept_state) {
					throw (new Error("Lexical Error: Unmatched Input."));
				}
				else {
					yy_anchor = yy_acpt[yy_last_accept_state];
					if (0 != (YY_END & yy_anchor)) {
						yy_move_end();
					}
					yy_to_mark();
					switch (yy_last_accept_state) {
					case 0:
						{
                  // The token is a ~realAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  if (yytext().equals(".")){
                    // This special case is not accepted by the method
                    // valueOf() in the Double class, but must be interpretted
                    // by this scanner as the  point number 0.0
                    // Hence, this special case is "parsed" by hand.
                    value = ListExpr.realAtom(0.0);
                    return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                           yyline+1));
                  }
                  try{
                    value = ListExpr.realAtom(Double.parseDouble(yytext()));
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                      Reporter.writeError("DEBUG MODE: Error when parsing a real number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                         yyline+1));
                }
					case -2:
						break;
					case 1:
						
					case -3:
						break;
					case 2:
						{}
					case -4:
						break;
					case 3:
						{
                  // The token is an ~intAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  try{
                    value = ListExpr.intAtom(Integer.valueOf(yytext()).intValue());
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                      Reporter.writeError("DEBUG MODE: Error when parsing an integer number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_INT_ATOM, value, yychar+1,
                         yyline+1));
                }
					case -5:
						break;
					case 4:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -6:
						break;
					case 5:
						{
                  // If an unknown token is read.
                  if (NLTokenizer.DEBUG_MODE){
                    Reporter.writeError("DEBUG MODE: Error: Unknown token found when scanning the input in the NLTokenizer class.");
                    Reporter.writeError("The value is'"+yytext()+"'");
                  }
                  return (new NLToken(NLToken.error, null, yychar+1,
                          yyline+1));
                }
					case -7:
						break;
					case 6:
						{
                  // If it finds a CLOSE_PAR token.
                  return(new NLToken(NLToken.TT_CLOSE_PAR, null, yychar+1,
                         yyline+1));
                }
					case -8:
						break;
					case 7:
						{ yybegin(TEXTATOM_SIMPLE);
                  this.textContent.setLength(0);
               }
					case -9:
						break;
					case 8:
						{
                  // If it finds an OPEN_PAR token.
                  return(new NLToken(NLToken.TT_OPEN_PAR, null, yychar+1,
                         yyline+1));
                }
					case -10:
						break;
					case 10:
						{
                  // If it finds an ~stringAtom~, it returns its content,
                  // without the doble quotes at the start and end.
                  String s = yytext().substring(1,yytext().length()-1);
                  s = ListExpr.replaceAll(s,"\\\"","\"");
                  s = ListExpr.replaceAll(s,"\\\\","\\");
                  return(new NLToken(NLToken.TT_STRING_ATOM,
                         ListExpr.stringAtom(s),
                         yychar+1, yyline+1));
                }
					case -11:
						break;
					case 11:
						{
                            yybegin(COMMENT_STATE);
                           }
					case -12:
						break;
					case 12:
						{
                  // The token is a ~boolAtom~.
                  return(new NLToken(NLToken.TT_BOOL_ATOM,
                         ListExpr.boolAtom(true), yychar+1, yyline+1));
               }
					case -13:
						break;
					case 13:
						{
                  // The token is a ~boolAtom~.
                  return(new NLToken(NLToken.TT_BOOL_ATOM,
                         ListExpr.boolAtom(false), yychar+1, yyline+1));
               }
					case -14:
						break;
					case 14:
						{
                  // If it finds the ~start of textAtom~ label, it changes the
                  // state to TEXTATOM_STATE. In this state characters are
                  // readed until the end of textatom label "</text--->" is
                  // found.
                  yybegin(TEXTATOM_STATE);
                  // the buffer for the content is set to the empty string.
                  this.textContent.setLength(0);
                }
					case -15:
						break;
					case 15:
						{
                     // first extract the real filename
                     String FNWithTags = yytext();
                     String FN = FNWithTags.substring(6,FNWithTags.length()-10).trim();
                     try{
                        String Directory = ListExpr.getDirectory();
                        String fn = null;
                        if(!FN.startsWith(File.separator)){
                           if(Directory==null){
                              Reporter.writeError("Directory shound not be null");
                           }
                           if(!Directory.endsWith(File.separator)){
                               Directory += File.separatorChar;
                           }
                           fn = Directory + FN;
                        } else {
                           fn = FN;
                        }
                        File F = new File(fn);
                        long size = F.length();
                        long encodedSize = Base64Encoder.getEncodedSize(size);
                        BufferedInputStream in = new BufferedInputStream(new FileInputStream(F));
                        Base64Encoder Enc = new Base64Encoder(in);
                        StringBuffer Content = new StringBuffer((int)encodedSize+1);
                        int next;
                        while( (next = Enc.getNext())>=0)
                               Content.append((char)next);
                        in.close();
                        return( new NLToken(NLToken.TT_TEXT_ATOM,
                                ListExpr.textAtom(Content.toString()),
                                yychar+1,yyline+1));
                     } catch(Exception e){
                        if(DEBUG_MODE){
                            Reporter.writeError("error in reading binary data from file");
                                              Reporter.debug(e);
                        }
                         return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                     }
                }
					case -16:
						break;
					case 16:
						{
                  // For any character, given that it has not detected the ~end
                  // of textatom~ label, the readed character belongs to the
                  // content of the textatom. So, it stores the character.
                  this.textContent.append(yytext());
                }
					case -17:
						break;
					case 17:
						{
                  this.textContent.append("\\");
             }
					case -18:
						break;
					case 18:
						{
                  // if it finds the ~end of textAtom~ label, it restores the
                  // state to the initial state (YYINITIAL) and returns the
                  // read string.
                    yybegin(YYINITIAL);
                String completeText =  this.textContent.toString();
                  // Erases the content of ~textContent~.
                      this.textContent.setLength(0);
                  return(new NLToken(NLToken.TT_TEXT_ATOM,
                         ListExpr.textAtom(completeText),
                         yychar+1, yyline+1));
}
					case -19:
						break;
					case 19:
						{
                  this.textContent.append("</text--->");
}
					case -20:
						break;
					case 20:
						{
  this.textContent.append(yytext());
}
					case -21:
						break;
					case 21:
						{
                    yybegin(YYINITIAL);
                    String completeText = this.textContent.toString();
                    this.textContent.setLength(0);
                    return(new NLToken(NLToken.TT_TEXT_ATOM,
                           ListExpr.textAtom(completeText),
                           yychar+1, yyline+1));
                }
					case -22:
						break;
					case 22:
						{
                       this.textContent.append("\\");
}
					case -23:
						break;
					case 23:
						{
  this.textContent.append("'");
}
					case -24:
						break;
					case 24:
						{
                           }
					case -25:
						break;
					case 25:
						{
                             yybegin(YYINITIAL);
                            }
					case -26:
						break;
					case 26:
						{
                  // The token is a ~realAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  if (yytext().equals(".")){
                    // This special case is not accepted by the method
                    // valueOf() in the Double class, but must be interpretted
                    // by this scanner as the  point number 0.0
                    // Hence, this special case is "parsed" by hand.
                    value = ListExpr.realAtom(0.0);
                    return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                           yyline+1));
                  }
                  try{
                    value = ListExpr.realAtom(Double.parseDouble(yytext()));
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                      Reporter.writeError("DEBUG MODE: Error when parsing a real number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                         yyline+1));
                }
					case -27:
						break;
					case 27:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -28:
						break;
					case 28:
						{
                  // If an unknown token is read.
                  if (NLTokenizer.DEBUG_MODE){
                    Reporter.writeError("DEBUG MODE: Error: Unknown token found when scanning the input in the NLTokenizer class.");
                    Reporter.writeError("The value is'"+yytext()+"'");
                  }
                  return (new NLToken(NLToken.error, null, yychar+1,
                          yyline+1));
                }
					case -29:
						break;
					case 30:
						{
                  // If it finds an ~stringAtom~, it returns its content,
                  // without the doble quotes at the start and end.
                  String s = yytext().substring(1,yytext().length()-1);
                  s = ListExpr.replaceAll(s,"\\\"","\"");
                  s = ListExpr.replaceAll(s,"\\\\","\\");
                  return(new NLToken(NLToken.TT_STRING_ATOM,
                         ListExpr.stringAtom(s),
                         yychar+1, yyline+1));
                }
					case -30:
						break;
					case 31:
						{
                  // For any character, given that it has not detected the ~end
                  // of textatom~ label, the readed character belongs to the
                  // content of the textatom. So, it stores the character.
                  this.textContent.append(yytext());
                }
					case -31:
						break;
					case 32:
						{
  this.textContent.append(yytext());
}
					case -32:
						break;
					case 33:
						{
                           }
					case -33:
						break;
					case 34:
						{
                  // The token is a ~realAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  if (yytext().equals(".")){
                    // This special case is not accepted by the method
                    // valueOf() in the Double class, but must be interpretted
                    // by this scanner as the  point number 0.0
                    // Hence, this special case is "parsed" by hand.
                    value = ListExpr.realAtom(0.0);
                    return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                           yyline+1));
                  }
                  try{
                    value = ListExpr.realAtom(Double.parseDouble(yytext()));
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                      Reporter.writeError("DEBUG MODE: Error when parsing a real number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                         yyline+1));
                }
					case -34:
						break;
					case 35:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -35:
						break;
					case 37:
						{
                  // For any character, given that it has not detected the ~end
                  // of textatom~ label, the readed character belongs to the
                  // content of the textatom. So, it stores the character.
                  this.textContent.append(yytext());
                }
					case -36:
						break;
					case 38:
						{
                  // The token is a ~realAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  if (yytext().equals(".")){
                    // This special case is not accepted by the method
                    // valueOf() in the Double class, but must be interpretted
                    // by this scanner as the  point number 0.0
                    // Hence, this special case is "parsed" by hand.
                    value = ListExpr.realAtom(0.0);
                    return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                           yyline+1));
                  }
                  try{
                    value = ListExpr.realAtom(Double.parseDouble(yytext()));
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                      Reporter.writeError("DEBUG MODE: Error when parsing a real number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                         yyline+1));
                }
					case -37:
						break;
					case 39:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -38:
						break;
					case 41:
						{
                  // The token is a ~realAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  if (yytext().equals(".")){
                    // This special case is not accepted by the method
                    // valueOf() in the Double class, but must be interpretted
                    // by this scanner as the  point number 0.0
                    // Hence, this special case is "parsed" by hand.
                    value = ListExpr.realAtom(0.0);
                    return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                           yyline+1));
                  }
                  try{
                    value = ListExpr.realAtom(Double.parseDouble(yytext()));
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                      Reporter.writeError("DEBUG MODE: Error when parsing a real number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                         yyline+1));
                }
					case -39:
						break;
					case 42:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -40:
						break;
					case 44:
						{
                  // The token is a ~realAtom~.
                  // Gets its value.
                  ListExpr value = null;
                  if (yytext().equals(".")){
                    // This special case is not accepted by the method
                    // valueOf() in the Double class, but must be interpretted
                    // by this scanner as the  point number 0.0
                    // Hence, this special case is "parsed" by hand.
                    value = ListExpr.realAtom(0.0);
                    return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                           yyline+1));
                  }
                  try{
                    value = ListExpr.realAtom(Double.parseDouble(yytext()));
                  }
                  catch (NumberFormatException except){
                    // If an error when parsing occur, an unknown token was
                    // read.
                    if (NLTokenizer.DEBUG_MODE){
                      Reporter.writeError("DEBUG MODE: Error when parsing a real number from the input in the NLTokenizer class.");
                    }
                    return (new NLToken(NLToken.error, null, yychar+1,
                            yyline+1));
                   }
                  // If the value was propertly parsed.
                  return(new NLToken(NLToken.TT_REAL_ATOM, value, yychar+1,
                         yyline+1));
                }
					case -41:
						break;
					case 45:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -42:
						break;
					case 70:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -43:
						break;
					case 73:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -44:
						break;
					case 75:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -45:
						break;
					case 76:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -46:
						break;
					case 79:
						{
                  // If it finds an ~symbolAtom~, it returns its content.
                  return(new NLToken(NLToken.TT_SYMBOL_ATOM,
                         ListExpr.symbolAtom(yytext()),
                         yychar+1, yyline+1));
                }
					case -47:
						break;
					default:
						yy_error(YY_E_INTERNAL,false);
					case -1:
					}
					yy_initial = true;
					yy_state = yy_state_dtrans[yy_lexical_state];
					yy_next_state = YY_NO_STATE;
					yy_last_accept_state = YY_NO_STATE;
					yy_mark_start();
					yy_this_accept = yy_acpt[yy_state];
					if (YY_NOT_ACCEPT != yy_this_accept) {
						yy_last_accept_state = yy_state;
						yy_mark_end();
					}
				}
			}
		}
	}
}
