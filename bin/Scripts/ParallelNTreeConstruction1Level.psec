/*
//paragraph [10] Title: [{\Large \bf ]  [}]
//[@] [\verb+@+]
//[%] [\%]
//[&] [\&]
//[ue] [\"{u}]

[10] Parallel Construction of an N-tree

Ralf Hartmut G[ue]ting, February 24, 2022

Run this script with ~SecondoTTYBDB~ and prefix [@][%] or [@][&]. 



1 The Database

Database newyorkm80c on newton1. 

Workers relation seems to correspond to ClusterRalfNewton80.

----	remoteMonitors ClusterRalfNewton80 start
----

There is a distributed array TripsCM200D with 320 fields and 553470 tuples. So we have a correct distributed version of TripsCM200.

We have 80 workers and build an N-tree of degree 80.

*/
# @%Scripts/DistCost.sec

/*

2 Select Centers for the Root Node

*/
# query TripsCM200D dmap["", . count] getValue tie[. + ..]

let_ Centers80 = TripsCM200D dmap["", . feed some[1]] dsummarize some[80] 
  addcounter[N1, 0] consume

# [5.9 seconds] 3.67 seconds

query share("Centers80", TRUE, Workers)

# [1.75 seconds] 1.26 seconds

/*
3 Distribution to Root Centers (Level 0)

*/

query TripsCM200D dcommand['query memclear()'] filter[.Ok] count;
query TripsCM200D dcommand['query meminit(1800)'] filter[.Ok] count;

query TripsCM200D dlet["Centers80m", 'Centers80 feed mconsume'] 
  filter[.Ok] count

# 0.18 seconds
# result 81 (1 on master)

/*
We build N-trees with a single leaf.

*/
query TripsCM200D dlet["Centers80m_ntree", 'Centers80m 
  mcreatentree7[Trip, 350, 1000]'] filter[.Ok] count
  
# 4.28 seconds, 3160 distance computations = 40 * 79 for 80 centers

let_ Trips8001a = TripsCM200D dmap["Trips8001", 
  . feed 
  loopjoin[Centers80m_ntree Centers80m m1nearestNeighborN7[.Trip] 
    project[N1, QueryObjectDistance]]  
  consume]
  partition["", .N1, 80]
  
# 3:30 min = 210 seconds

let_ Trips8001 = Trips8001a areduce["", . feed consume, myPort]

# let_ Trips8001 = Trips8001a collect2["",  myPort]

# 21.73 seconds

/*
4 Creating N-trees at Level 1

*/
let_ Trips8001m = Trips8001 dmap["", . feed mconsumeflob]

# [2.4 seconds] 1.74 seconds, 3.98 seconds

update LastCommand := distCostReset(ControlWorkers)

let_ Trips8001m_ntree = Trips8001m dmap["", . mcreatentree7[Trip, 80, 160]]

# [7:31 min = 451 seconds] 14:04 min = 843 seconds, 14:30 min

let_ Cost3 = distCostSave(ControlWorkers)

query Trips8001m dmap["", . count] dsummarize transformstream max[Elem]

# [6.2 seconds] 0.47 seconds
# [result 6775] result 24789

/*
Node numbering for export must keep the node numbers for all trees disjoint and must leave out 0, the node number for the root node, therefore start at 1.

In repeated use, we first need to remove previously created tree relations.

*/
query TripsCM200D dcommand['query getcatalog() 
  filter[.ObjectName starts "Trips8001Z"] project[ObjectName] 
  extend[Deleted: deleteObject(.ObjectName)] count'] filter[.Ok] count;

query Trips8001m_ntree Trips8001m 
  dmap2["", . .. exportntree["Trips8001Z", 1 + ($3 * 30000), $3], myPort]

# [1:14 min] 9.6 seconds, 9.08 seconds

/*
5 Computing Tree Relations for the Root Node

*/
query Centers80 getTypeNL

# (rel (tuple ((Trip_id int) (PickupTime instant) (DropoffTime instant) 
# (TotalDistance real) (TotalDuration duration) (SpeedKmh real) 
# (Trip mpoint) 
# (CM cmpoint) (N1 int))))

query Trips8001NodeInfo getTypeNL

#  (rel (tuple ((Trip_id int) (PickupTime instant) (DropoffTime instant) 
# (TotalDistance real) (TotalDuration duration) (SpeedKmh real) 
# (Trip mpoint) 
# (CM cmpoint) (N1 int) (QueryObjectDistance real) (NodeId int) 
# (Entry int) 
# (Subtree int) (MaxDist real))))

let_ RootNodeDist = Centers80 feed Centers80 feed {c2} product 
  filter[.N1 < .N1_c2]
  projectextend[; NodeId: 0, Entry1: .N1, Entry2: .N1_c2, 
    Distance: distanceAvg(.Trip, .Trip_c2)]
  consume
 
# 2.28 seconds

let_ MaxDistances = Trips8001 dmap["", . feed 
  groupby[N1; MaxDist: group feed max[QueryObjectDistance]]] 
  dsummarize consume
  
# 4.4 seconds

let_ RootNodeInfo = Centers80 feed extend[QueryObjectDistance: 0.0, 
  NodeId: 0, Entry: .N1, Subtree: 1 + (.N1 * 30000)]
  MaxDistances feed {m}
  itHashJoin[N1, N1_m]
  extend[MaxDist: .MaxDist_m]
  remove[N1_m, MaxDist_m]
  consume
  
# 0.42 seconds

let_ RootPivotInfo = 
  Centers80 feed extract[Trip] funseq2[
    fun(elem1: ARGEF1, elem2: ARGEF2)
      Centers80 feed head[2] tail[1] extract[Trip],
    fun(pivot1: ARGEF1, pivot2: ARGEF2)  
    Centers80 feed projectextend[; NodeId: 0, Entry: .N1, 
      PivotDist1: distanceAvg(.Trip, pivot1),
      PivotDist2: distanceAvg(.Trip, pivot2),
      IsPivot: .N1 < 2]
    consume     
  ]

# 0.44 seconds, 0.46


/*
6 Collecting Exported Relations on the Master

Defining relation types:

*/
(let_ Trips8001ZNodeDist_type = (
  (rel (tuple ((NodeId int) (Entry1 int) (Entry2 int) (Distance real))))
()))

(let_ Trips8001ZNodeInfo_type = (
  (rel (tuple ((Trip_id int) (PickupTime instant) (DropoffTime instant) 
(TotalDistance real) (TotalDuration duration) (SpeedKmh real) 
(Trip mpoint) 
(CM cmpoint) (N1 int) (QueryObjectDistance real) (NodeId int) (Entry int) 
(Subtree int) (MaxDist real))))
()))

(let_ Trips8001ZPivotInfo_type = (
  (rel (tuple ((NodeId int) (Entry int) (PivotDist1 real) 
  (PivotDist2 real) (IsPivot bool))))
()))

/*
Creating darrays over relations on workers:

*/
let_ NSlots = 80;

let_ Trips8001ZNodeDist = Workers feed 
  createDArray["Trips8001ZNodeDist", NSlots, 
  Trips8001ZNodeDist_type, TRUE]
  
# ~ 11.5 seconds
  
let_ Trips8001ZNodeInfo = Workers feed 
  createDArray["Trips8001ZNodeInfo", NSlots, 
  Trips8001ZNodeInfo_type, TRUE]
  
# 11.67 seconds

let_ Trips8001ZPivotInfo = Workers feed 
  createDArray["Trips8001ZPivotInfo", NSlots, 
  Trips8001ZPivotInfo_type, TRUE]
  
# 11.47 seconds

query Trips8001ZNodeDist dmap["", . count] getValue tie[. + ..]

# 17234502

query Trips8001ZNodeInfo dmap["", . count] getValue tie[. + ..];
query Trips8001ZPivotInfo dmap["", . count] getValue tie[. + ..]

# 634510
# 634510

/*
Building the Complete Tree Relations

*/


let_ Trips8001NodeDist = RootNodeDist feed
  Trips8001ZNodeDist dsummarize concat
  consume

# 4:26 min = 265 seconds, 4:40 min

let_ Trips8001NodeInfo = RootNodeInfo feed
  Trips8001ZNodeInfo dsummarize concat
  consume;

# 6:02 min = 362 seconds, 5.54 min

let_ Trips8001PivotInfo = RootPivotInfo feed
  Trips8001ZPivotInfo dsummarize concat
  consume;

# 14.75 seconds, 11.79





